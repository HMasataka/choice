<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC SFU Client</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        margin: 0;
        padding: 20px;
        background: #1a1a2e;
        color: #eee;
      }
      h1 {
        text-align: center;
        margin-bottom: 20px;
      }
      .controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }
      .controls input {
        padding: 10px;
        border: 1px solid #444;
        border-radius: 4px;
        background: #2a2a4e;
        color: #eee;
      }
      .controls button {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        transition: background 0.2s;
      }
      #joinBtn {
        background: #4caf50;
        color: white;
      }
      #joinBtn:hover {
        background: #45a049;
      }
      #leaveBtn {
        background: #f44336;
        color: white;
      }
      #leaveBtn:hover {
        background: #da190b;
      }
      #leaveBtn:disabled {
        background: #666;
        cursor: not-allowed;
      }
      .video-container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        justify-content: center;
      }
      .video-box {
        background: #2a2a4e;
        border-radius: 8px;
        padding: 10px;
        max-width: 480px;
      }
      .video-box h3 {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: #aaa;
      }
      video {
        width: 100%;
        max-width: 460px;
        border-radius: 4px;
        background: #000;
      }
      #localVideo {
        transform: scaleX(-1);
      }
      .status {
        text-align: center;
        padding: 10px;
        margin-bottom: 20px;
        border-radius: 4px;
        background: #2a2a4e;
      }
      .status.connected {
        background: #1b5e20;
      }
      .status.disconnected {
        background: #b71c1c;
      }
      #remoteVideos {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        justify-content: center;
      }
      .layer-controls {
        margin-top: 8px;
        display: flex;
        gap: 5px;
        justify-content: center;
      }
      .layer-btn {
        padding: 5px 10px;
        border: 1px solid #666;
        border-radius: 4px;
        background: #3a3a5e;
        color: #eee;
        cursor: pointer;
        font-size: 12px;
      }
      .layer-btn:hover {
        background: #4a4a6e;
      }
      .layer-btn.active {
        background: #4caf50;
        border-color: #4caf50;
      }
      .simulcast-info {
        font-size: 11px;
        color: #888;
        margin-top: 5px;
        text-align: center;
      }
      .log {
        margin-top: 20px;
        padding: 10px;
        background: #2a2a4e;
        border-radius: 4px;
        max-height: 200px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 12px;
      }
      .log-entry {
        margin: 2px 0;
        padding: 2px 5px;
      }
      .log-entry.error {
        color: #ff6b6b;
      }
      .log-entry.info {
        color: #4ecdc4;
      }
      .chat-container {
        margin-top: 20px;
        padding: 15px;
        background: #2a2a4e;
        border-radius: 8px;
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
      }
      .chat-container h3 {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: #aaa;
      }
      .chat-messages {
        height: 150px;
        overflow-y: auto;
        background: #1a1a2e;
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 10px;
      }
      .chat-message {
        margin: 5px 0;
        padding: 5px 10px;
        border-radius: 4px;
        background: #3a3a5e;
      }
      .chat-message.own {
        background: #4caf50;
        text-align: right;
      }
      .chat-message .sender {
        font-size: 11px;
        color: #aaa;
        margin-bottom: 2px;
      }
      .chat-message.own .sender {
        color: #c8e6c9;
      }
      .chat-input-container {
        display: flex;
        gap: 10px;
      }
      .chat-input-container input {
        flex: 1;
        padding: 10px;
        border: 1px solid #444;
        border-radius: 4px;
        background: #1a1a2e;
        color: #eee;
      }
      .chat-input-container button {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        background: #2196f3;
        color: white;
        cursor: pointer;
        font-weight: bold;
      }
      .chat-input-container button:hover {
        background: #1976d2;
      }
      .chat-input-container button:disabled {
        background: #666;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <h1>WebRTC SFU Client</h1>

    <div class="status" id="status">Disconnected</div>

    <div class="controls">
      <input
        type="text"
        id="serverUrl"
        placeholder="WebSocket URL"
        value="ws://localhost:8080/ws"
      />
      <input
        type="text"
        id="sessionId"
        placeholder="Session ID"
        value="room1"
      />
      <input type="text" id="peerId" placeholder="Peer ID" value="" />
      <button id="joinBtn">Join</button>
      <button id="leaveBtn" disabled>Leave</button>
    </div>

    <div class="video-container">
      <div class="video-box">
        <h3>Local Video</h3>
        <video id="localVideo" autoplay muted playsinline></video>
      </div>
    </div>

    <div id="remoteVideos"></div>

    <div class="chat-container">
      <h3>Chat (DataChannel)</h3>
      <div class="chat-messages" id="chatMessages"></div>
      <div class="chat-input-container">
        <input
          type="text"
          id="chatInput"
          placeholder="Type a message..."
          disabled
        />
        <button id="sendBtn" disabled>Send</button>
      </div>
    </div>

    <div class="log" id="log"></div>

    <script>
      const localVideo = document.getElementById("localVideo");
      const remoteVideosContainer = document.getElementById("remoteVideos");
      const joinBtn = document.getElementById("joinBtn");
      const leaveBtn = document.getElementById("leaveBtn");
      const statusEl = document.getElementById("status");
      const logEl = document.getElementById("log");
      const serverUrlInput = document.getElementById("serverUrl");
      const sessionIdInput = document.getElementById("sessionId");
      const peerIdInput = document.getElementById("peerId");
      const chatMessagesEl = document.getElementById("chatMessages");
      const chatInput = document.getElementById("chatInput");
      const sendBtn = document.getElementById("sendBtn");

      let ws = null;
      let publisherPC = null;
      let subscriberPC = null;
      let localStream = null;
      let publisherDataChannel = null;
      let rpcId = 0;
      let pendingRequests = new Map();

      // Generate random peer ID if not set
      if (!peerIdInput.value) {
        peerIdInput.value = "peer-" + Math.random().toString(36).substr(2, 9);
      }

      function log(message, type = "info") {
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logEl.appendChild(entry);
        logEl.scrollTop = logEl.scrollHeight;
        console.log(message);
      }

      function setStatus(text, connected) {
        statusEl.textContent = text;
        statusEl.className =
          "status " + (connected ? "connected" : "disconnected");
      }

      function sendRPC(method, params) {
        return new Promise((resolve, reject) => {
          const id = ++rpcId;
          const request = {
            jsonrpc: "2.0",
            id: id,
            method: method,
            params: params,
          };

          pendingRequests.set(id, { resolve, reject });
          ws.send(JSON.stringify(request));
          log(`-> ${method}: ${JSON.stringify(params)}`);
        });
      }

      function handleRPCResponse(response) {
        if (response.id && pendingRequests.has(response.id)) {
          const { resolve, reject } = pendingRequests.get(response.id);
          pendingRequests.delete(response.id);

          if (response.error) {
            reject(new Error(response.error.message));
          } else {
            resolve(response.result);
          }
        }
      }

      async function handleNotification(notification) {
        log(
          `<- ${notification.method}: ${JSON.stringify(notification.params)}`,
        );

        try {
          switch (notification.method) {
            case "offer":
              await handleOffer(notification.params.offer);
              break;
            case "candidate":
              await handleCandidate(notification.params);
              break;
            case "trackAdded":
              await handleTrackAdded(notification.params);
              break;
          }
        } catch (err) {
          log(
            `Error in handleNotification(${notification.method}): ${err.message}`,
            "error",
          );
          console.error(err);
        }
      }

      async function handleOffer(offer) {
        if (!subscriberPC) {
          await createSubscriberPC();
        }

        await subscriberPC.setRemoteDescription(offer);
        const answer = await subscriberPC.createAnswer();
        await subscriberPC.setLocalDescription(answer);

        sendRPC("answer", {
          sessionId: sessionIdInput.value,
          peerId: peerIdInput.value,
          answer: answer,
        });
      }

      async function handleCandidate(params) {
        const pc = params.target === "subscriber" ? subscriberPC : publisherPC;
        if (pc && params.candidate) {
          await pc.addIceCandidate(params.candidate);
        }
      }

      const subscribedPeers = new Set();

      // Track info: serverTrackId -> info
      const simulcastTracks = new Map();
      // Mapping from streamId to serverTrackId
      const streamToTrackId = new Map();

      async function handleTrackAdded(params) {
        log(
          `Track added from peer ${params.peerId}: ${params.kind} (trackId: ${params.trackId}, streamId: ${params.streamId})`,
        );

        // Store track info and update UI for video tracks
        if (params.kind === "video") {
          simulcastTracks.set(params.trackId, {
            peerId: params.peerId,
            streamId: params.streamId,
            currentLayer: "mid",
          });
          streamToTrackId.set(params.streamId, params.trackId);
          log(
            `Mapped streamId ${params.streamId} to trackId ${params.trackId}`,
          );

          // Update existing layer control buttons with correct trackId
          updateLayerControlsTrackId(params.streamId, params.trackId);
        }

        // Only subscribe once per peer
        if (subscribedPeers.has(params.peerId)) {
          log(`Already subscribed to peer ${params.peerId}, skipping`);
          return;
        }
        subscribedPeers.add(params.peerId);

        // Subscribe to the new track
        await sendRPC("subscribe", {
          sessionId: sessionIdInput.value,
          peerId: peerIdInput.value,
          targetPeerId: params.peerId,
        });
      }

      // Update layer control buttons with the correct server trackId
      function updateLayerControlsTrackId(streamId, serverTrackId) {
        const layerControls = document.getElementById(`layers-${streamId}`);
        if (layerControls) {
          const buttons = layerControls.querySelectorAll(".layer-btn");
          buttons.forEach((btn) => {
            btn.dataset.trackId = serverTrackId;
            btn.onclick = () => setLayer(serverTrackId, btn.dataset.layer);
          });
          log(
            `Updated layer controls for stream ${streamId} with trackId ${serverTrackId}`,
          );
        }
      }

      async function setLayer(trackId, layer) {
        try {
          await sendRPC("setLayer", {
            sessionId: sessionIdInput.value,
            peerId: peerIdInput.value,
            trackId: trackId,
            layer: layer,
          });

          // Update UI
          const info = simulcastTracks.get(trackId);
          if (info) {
            info.currentLayer = layer;
            updateLayerButtons(trackId, layer);
          }
          log(`Set layer to ${layer} for track ${trackId}`);
        } catch (err) {
          log(`Error setting layer: ${err.message}`, "error");
        }
      }

      function updateLayerButtons(trackId, activeLayer) {
        const buttons = document.querySelectorAll(
          `[data-track-id="${trackId}"]`,
        );
        buttons.forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.layer === activeLayer);
        });
      }

      async function createSubscriberPC() {
        subscriberPC = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        });

        subscriberPC.onicecandidate = (e) => {
          if (e.candidate) {
            sendRPC("candidate", {
              sessionId: sessionIdInput.value,
              peerId: peerIdInput.value,
              candidate: e.candidate.toJSON(),
              target: "subscriber",
            });
          }
        };

        subscriberPC.ontrack = (e) => {
          log(`Received remote track: ${e.track.kind}`);
          const stream = e.streams[0] || new MediaStream([e.track]);
          addRemoteStream(stream, e.track);
        };

        subscriberPC.onconnectionstatechange = () => {
          log(`Subscriber connection state: ${subscriberPC.connectionState}`);
        };

        // Handle incoming data channel from SFU
        subscriberPC.ondatachannel = (e) => {
          log(`Received data channel: ${e.channel.label}`);
          const dc = e.channel;

          dc.onopen = () => {
            log("Subscriber data channel opened");
          };

          dc.onmessage = (event) => {
            try {
              let data = event.data;
              // Convert ArrayBuffer to string if needed
              if (data instanceof ArrayBuffer) {
                data = new TextDecoder().decode(data);
              }
              const msg = JSON.parse(data);
              addChatMessage(msg.sender, msg.text, false);
            } catch (err) {
              log(`Error parsing chat message: ${err.message}`, "error");
            }
          };

          dc.onclose = () => {
            log("Subscriber data channel closed");
          };
        };
      }

      const remoteStreams = new Map();

      function addRemoteStream(stream, track) {
        const streamId = stream.id;
        const serverTrackId = streamToTrackId.get(streamId);

        if (!remoteStreams.has(streamId)) {
          remoteStreams.set(streamId, stream);

          const videoBox = document.createElement("div");
          videoBox.className = "video-box";
          videoBox.id = `remote-${streamId}`;

          const title = document.createElement("h3");
          title.textContent = `Remote: ${streamId.substr(0, 8)}`;

          const video = document.createElement("video");
          video.autoplay = true;
          video.playsinline = true;
          video.srcObject = stream;

          video.onloadedmetadata = () => {
            log(`Video metadata loaded for stream ${streamId}`);
            video
              .play()
              .catch((err) => log(`Video play error: ${err}`, "error"));
          };

          videoBox.appendChild(title);
          videoBox.appendChild(video);

          // Add layer controls for video streams
          const layerControls = document.createElement("div");
          layerControls.className = "layer-controls";
          layerControls.id = `layers-${streamId}`;

          const trackIdForControls = serverTrackId || track.id;

          ["low", "mid", "high"].forEach((layer) => {
            const btn = document.createElement("button");
            btn.className = `layer-btn ${layer === "mid" ? "active" : ""}`;
            btn.textContent = layer.toUpperCase();
            btn.dataset.trackId = trackIdForControls;
            btn.dataset.streamId = streamId;
            btn.dataset.layer = layer;
            btn.onclick = () => setLayer(trackIdForControls, layer);
            layerControls.appendChild(btn);
          });

          const info = document.createElement("div");
          info.className = "simulcast-info";
          info.textContent = "Simulcast Layer Control";

          videoBox.appendChild(layerControls);
          videoBox.appendChild(info);

          remoteVideosContainer.appendChild(videoBox);
        } else {
          const existingStream = remoteStreams.get(streamId);
          if (!existingStream.getTrackById(track.id)) {
            existingStream.addTrack(track);
          }
        }
      }

      async function join() {
        try {
          // Get local media with higher resolution for simulcast
          localStream = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 },
              frameRate: { ideal: 30 },
            },
            audio: true,
          });
          localVideo.srcObject = localStream;
          log("Got local media stream");

          // Connect WebSocket
          ws = new WebSocket(serverUrlInput.value);

          ws.onopen = async () => {
            log("WebSocket connected");
            setStatus("Connected", true);

            // Create publisher peer connection
            publisherPC = new RTCPeerConnection({
              iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
            });

            publisherPC.onicecandidate = (e) => {
              if (e.candidate) {
                sendRPC("candidate", {
                  sessionId: sessionIdInput.value,
                  peerId: peerIdInput.value,
                  candidate: e.candidate.toJSON(),
                  target: "publisher",
                });
              }
            };

            publisherPC.onconnectionstatechange = () => {
              log(`Publisher connection state: ${publisherPC.connectionState}`);
            };

            // Create data channel for sending chat messages
            publisherDataChannel = publisherPC.createDataChannel("chat");
            publisherDataChannel.onopen = () => {
              log("Publisher data channel opened");
              chatInput.disabled = false;
              sendBtn.disabled = false;
            };
            publisherDataChannel.onclose = () => {
              log("Publisher data channel closed");
              chatInput.disabled = true;
              sendBtn.disabled = true;
            };

            // Add local tracks with simulcast for video
            localStream.getTracks().forEach((track) => {
              if (track.kind === "video") {
                // Use addTransceiver for simulcast
                const transceiver = publisherPC.addTransceiver(track, {
                  streams: [localStream],
                  sendEncodings: [
                    {
                      rid: "low",
                      maxBitrate: 80000,
                      scaleResolutionDownBy: 8,
                      active: true,
                    }, // 160x90 @ 80kbps - clearly low quality
                    {
                      rid: "mid",
                      maxBitrate: 250000,
                      scaleResolutionDownBy: 4,
                      active: true,
                    }, // 320x180 @ 250kbps - medium quality
                    { rid: "high", maxBitrate: 2500000, active: true }, // 1280x720 @ 2.5Mbps - full quality
                  ],
                });
                log(`Added video track with simulcast: ${track.id}`);

                // Monitor and force enable all layers
                setTimeout(async () => {
                  const sender = transceiver.sender;
                  const params = sender.getParameters();
                  log(
                    `Current encodings: ${JSON.stringify(params.encodings.map((e) => ({ rid: e.rid, active: e.active })))}`,
                  );

                  // Force all layers to be active
                  let needsUpdate = false;
                  params.encodings.forEach((enc) => {
                    if (!enc.active) {
                      enc.active = true;
                      needsUpdate = true;
                    }
                  });

                  if (needsUpdate) {
                    await sender.setParameters(params);
                    log("Forced all simulcast layers to active");
                  }
                }, 2000);
              } else {
                publisherPC.addTrack(track, localStream);
                log(`Added audio track: ${track.id}`);
              }
            });

            // Create and send offer
            const offer = await publisherPC.createOffer();
            await publisherPC.setLocalDescription(offer);

            const result = await sendRPC("join", {
              sessionId: sessionIdInput.value,
              peerId: peerIdInput.value,
              offer: offer,
            });

            await publisherPC.setRemoteDescription(result.answer);
            log("Joined session successfully");

            joinBtn.disabled = true;
            leaveBtn.disabled = false;
          };

          ws.onmessage = async (e) => {
            try {
              const data = JSON.parse(e.data);
              console.log(
                "Received message:",
                JSON.stringify(data).substring(0, 200),
              );

              // Check for notification first (has method, no id or id is null)
              if (data.method) {
                await handleNotification(data);
              } else if (data.id !== undefined && data.id !== null) {
                handleRPCResponse(data);
              } else {
                log(`Unknown message format: ${JSON.stringify(data)}`, "error");
              }
            } catch (err) {
              log(`Error handling message: ${err.message}`, "error");
              console.error(err);
            }
          };

          ws.onclose = () => {
            log("WebSocket disconnected");
            setStatus("Disconnected", false);
            cleanup();
          };

          ws.onerror = (e) => {
            log("WebSocket error", "error");
          };
        } catch (err) {
          log(`Error: ${err.message}`, "error");
        }
      }

      async function leave() {
        try {
          if (ws && ws.readyState === WebSocket.OPEN) {
            await sendRPC("leave", {
              sessionId: sessionIdInput.value,
              peerId: peerIdInput.value,
            });
          }
        } catch (err) {
          log(`Leave error: ${err.message}`, "error");
        }

        cleanup();
      }

      // Chat functions
      function addChatMessage(sender, text, isOwn) {
        const messageEl = document.createElement("div");
        messageEl.className = `chat-message ${isOwn ? "own" : ""}`;

        const senderEl = document.createElement("div");
        senderEl.className = "sender";
        senderEl.textContent = isOwn ? "You" : sender;

        const textEl = document.createElement("div");
        textEl.textContent = text;

        messageEl.appendChild(senderEl);
        messageEl.appendChild(textEl);
        chatMessagesEl.appendChild(messageEl);
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
      }

      function sendChatMessage() {
        const text = chatInput.value.trim();
        if (!text) return;

        if (
          publisherDataChannel &&
          publisherDataChannel.readyState === "open"
        ) {
          const msg = {
            sender: peerIdInput.value,
            text: text,
          };
          publisherDataChannel.send(JSON.stringify(msg));
          addChatMessage(peerIdInput.value, text, true);
          chatInput.value = "";
          log(`Sent chat message: ${text}`);
        } else {
          log("Data channel not open", "error");
        }
      }

      function cleanup() {
        if (publisherDataChannel) {
          publisherDataChannel.close();
          publisherDataChannel = null;
        }

        if (publisherPC) {
          publisherPC.close();
          publisherPC = null;
        }

        if (subscriberPC) {
          subscriberPC.close();
          subscriberPC = null;
        }

        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localStream = null;
        }

        if (ws) {
          ws.close();
          ws = null;
        }

        localVideo.srcObject = null;
        remoteVideosContainer.innerHTML = "";
        chatMessagesEl.innerHTML = "";
        chatInput.value = "";
        chatInput.disabled = true;
        sendBtn.disabled = true;
        remoteStreams.clear();
        subscribedPeers.clear();
        simulcastTracks.clear();
        streamToTrackId.clear();

        joinBtn.disabled = false;
        leaveBtn.disabled = true;
        setStatus("Disconnected", false);
      }

      joinBtn.addEventListener("click", join);
      leaveBtn.addEventListener("click", leave);
      sendBtn.addEventListener("click", sendChatMessage);
      chatInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          sendChatMessage();
        }
      });

      // Cleanup on page unload
      window.addEventListener("beforeunload", cleanup);
    </script>
  </body>
</html>
