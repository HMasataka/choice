# Simulcastにおけるスペーシャルレイヤーとテンポラルレイヤー

## 概要

WebRTCのSimulcast技術では、ネットワーク状況やデバイス性能に応じて動画品質を動的に調整するため、**スペーシャルレイヤー**と**テンポラルレイヤー**という2つの次元でレイヤー制御を行います。

## 基本概念

### スペーシャルレイヤー（Spatial Layer）

- **調整対象**: 解像度（画面サイズ）
- **例**: 320×240 → 640×480 → 1280×720
- **帯域への影響**: 大きい
- **視覚的効果**: 画質の明瞭さ

### テンポラルレイヤー（Temporal Layer）

- **調整対象**: フレームレート（時間軸での滑らかさ）
- **例**: 7.5fps → 15fps → 30fps
- **帯域への影響**: 中程度
- **視覚的効果**: 動きの滑らかさ

## 両レイヤーの比較

| 項目           | スペーシャルレイヤー | テンポラルレイヤー       |
| -------------- | -------------------- | ------------------------ |
| **調整範囲**   | 解像度（空間軸）     | フレームレート（時間軸） |
| **帯域効果**   | 大（2倍〜4倍の差）   | 中（1.5倍〜2倍の差）     |
| **CPU負荷**    | 高（デコード負荷大） | 中（フレーム処理頻度）   |
| **調整優先度** | 後（大きな変更）     | 先（軽微な変更）         |
| **待機時間**   | 5-10秒               | 3秒                      |
| **適用場面**   | 帯域に大きな変化     | 軽微なネットワーク変動   |

## レイヤー構成例

### 典型的な3層構成

```
レイヤー2: 1280×720@30fps  (高品質・高帯域)
    ├── テンポラル2: 30fps
    ├── テンポラル1: 15fps
    └── テンポラル0: 7.5fps

レイヤー1: 640×480@30fps   (中品質・中帯域)
    ├── テンポラル2: 30fps
    ├── テンポラル1: 15fps
    └── テンポラル0: 7.5fps

レイヤー0: 320×240@30fps   (低品質・低帯域)
    ├── テンポラル2: 30fps
    ├── テンポラル1: 15fps
    └── テンポラル0: 7.5fps
```

## 調整戦略

### 1. 品質向上時（良好なネットワーク）

**優先順位**: テンポラル → スペーシャル

```go
// ① まずテンポラルレイヤーを上げる（軽微な調整）
if canUpgradeTemporalLayer() {
    upgradeTemporalLayer()  // 15fps → 30fps
    return
}

// ② テンポラルが最大の場合のみスペーシャルを上げる
if canUpgradeSpatialLayer() {
    upgradeSpatialLayer()   // 480p → 720p + テンポラルは0にリセット
}
```

**理由**:

- テンポラルレイヤー調整は帯域変化が小さく、安全
- スペーシャルレイヤー変更は大きな帯域変化を伴うため慎重に

### 2. 品質低下時（劣悪なネットワーク）

**優先順位**: スペーシャル → テンポラル

```go
// ① まずスペーシャルレイヤーを下げる（効果的な帯域削減）
if canDowngradeSpatialLayer() {
    downgradeSpatialLayer()   // 720p → 480p
} else {
    // ② スペーシャルを下げられない場合のみテンポラル調整
    downgradeTemporalLayer()  // 30fps → 15fps
}
```

**理由**:

- 品質低下時は効果的な帯域削減が必要
- スペーシャルレイヤー変更の方が帯域削減効果が大きい

## 実装における定数定義

```go
// パケットロス率のしきい値
packetLossLowThreshold  = 5   // 5%以下は良好
packetLossHighThreshold = 25  // 25%以上は深刻

// ビットレート調整の倍率
bitrateUpgradeRatio   = 0.75  // テンポラル上げに必要（75%）
spatialUpgradeRatio   = 1.5   // スペーシャル上げに必要（150%）
bitrateDowngradeRatio = 0.625 // 下げを考慮する閾値（62.5%）

// レイヤー切り替え後の待機時間
temporalSwitchDelay = 3 * time.Second   // テンポラル変更後
spatialUpDelay      = 5 * time.Second   // スペーシャル上げ後
spatialDownDelay    = 10 * time.Second  // スペーシャル下げ後

// スペーシャルレイヤーの上限
maxSpatialLayerIndex = 2  // 0,1,2の3段階
```

## データ構造での管理

### スペーシャルレイヤー

```go
// 単純な整数値で管理
currentSpatialLayer := atomic.LoadInt32(&d.currentSpatialLayer)  // 0, 1, 2
targetSpatialLayer := atomic.LoadInt32(&d.targetSpatialLayer)    // 0, 1, 2
```

### テンポラルレイヤー

```go
// 32ビット整数に現在と目標を格納（ビット操作）
temporalLayer := atomic.LoadInt32(&d.temporalLayer)

// 下位4ビット: 現在のレイヤー
currentTemporal := temporalLayer & 0x0f

// 上位16ビット: 目標レイヤー
targetTemporal := temporalLayer >> 16
```

**なぜビット操作？**

- 現在と目標を1つの変数で原子的に管理
- レース条件を回避
- メモリ効率の向上

## VP8コーデックとの連携

### テンポラルレイヤーサポート

```go
// VP8でのテンポラルサポート確認
if d.mime == "video/vp8" {
    if vp8, ok := extPkt.Payload.(buffer.VP8); ok {
        d.simulcast.temporalSupported = vp8.TemporalSupported

        // VP8特有の参照フレーム情報
        d.simulcast.refPicID = vp8.PictureID
        d.simulcast.refTlZIdx = vp8.TL0PICIDX
    }
}
```

### パケットドロップ制御

```go
// テンポラルレイヤーでのパケット選択
if payload, picID, tlz0Idx, drop = setVP8TemporalLayer(extPkt, d); drop {
    d.snOffset++  // シーケンス番号の隙間を避ける調整
    return nil    // パケットをドロップ
}
```

## 実用的な使用例

### ビデオ会議での適応制御

#### シナリオ1: WiFi → 4G切り替え

```
初期状態: 720p@30fps (スペーシャル2, テンポラル2)
     ↓ (帯域悪化)
段階1: 720p@15fps (スペーシャル2, テンポラル1) ← テンポラル先行調整
     ↓ (さらに悪化)
段階2: 480p@15fps (スペーシャル1, テンポラル1) ← スペーシャル調整
     ↓ (改善)
段階3: 480p@30fps (スペーシャル1, テンポラル2) ← テンポラル先行回復
     ↓ (さらに改善)
最終: 720p@30fps (スペーシャル2, テンポラル2) ← スペーシャル回復
```

#### シナリオ2: 参加者増加による帯域圧迫

```
1対1通話: 720p@30fps
     ↓ (参加者追加)
多人数会議: 480p@30fps ← 解像度を下げてフレームレート維持
     ↓ (さらに参加者追加)
大規模会議: 480p@15fps ← フレームレートも調整
```

## 待機時間の意味

### なぜ待機が必要？

1. **ネットワーク状況の安定化**: 一時的な変動を排除
2. **振動現象の防止**: 頻繁な切り替えによる品質不安定を回避
3. **CPU負荷の分散**: 連続的な品質変更による負荷集中を防止

### 待機時間の設計思想

```go
temporalSwitchDelay = 3 * time.Second   // 軽微な変更：短い待機
spatialUpDelay      = 5 * time.Second   // 品質向上：中程度の待機
spatialDownDelay    = 10 * time.Second  // 品質低下：長い待機（慎重）
```

## 制限事項と考慮点

### 1. デバイス制限

- **モバイル端末**: スペーシャルレイヤー2（720p）が上限の場合が多い
- **低性能端末**: テンポラルレイヤー1（15fps）で十分な場合も

### 2. ネットワーク特性

- **有線接続**: 安定しているため頻繁な調整不要
- **モバイル回線**: 変動が大きいため積極的な調整が必要

### 3. コーデック依存

- **VP8**: テンポラルレイヤーサポートあり
- **H.264**: 実装依存
- **VP9/AV1**: より高度なレイヤー制御が可能

## まとめ

スペーシャルレイヤーとテンポラルレイヤーは、WebRTCにおいて**complementary（相補的）**な関係にあります：

- **テンポラルレイヤー**: 軽微で頻繁な調整に適している
- **スペーシャルレイヤー**: 大きな帯域変化に対応する

この2つの次元での制御により、様々なネットワーク環境とデバイス性能に対して、**段階的で自然な品質調整**を実現し、**最適なユーザー体験**を提供することができます。

## 関連ファイル

- **実装**: `pkg/sfu/downtrack.go`
- **VP8処理**: `pkg/sfu/utils.go` (setVP8TemporalLayer)
- **設定定数**: downtrack.go内の定数定義

